# SpecMCP Design Specification

**Version**: 1.1.0  
**Created**: 2026-02-11  
**Updated**: 2026-02-11  
**Status**: Design Complete

## Overview

SpecMCP is a Model Context Protocol (MCP) server that provides spec-driven development workflow using Emergent as its graph database backend. It enables AI coding assistants to work with structured specifications, track implementation progress, and coordinate parallel development work.

### Inspiration

SpecMCP is inspired by [OpenSpec](https://github.com/Fission-AI/OpenSpec), a spec-driven development framework. Unlike OpenSpec's file-based approach, SpecMCP uses Emergent's knowledge graph for:

- **Relationship tracking** - Entities connected via typed relationships
- **Impact analysis** - Query what's affected by changes
- **Versioning** - Built-in entity versioning and branching
- **Parallel execution** - Multiple agents working on related tasks

### Maturity Model

Following the industry maturity levels for specification adoption:

| Level | Definition | Code Role | SpecMCP Support |
|-------|------------|-----------|-----------------|
| **Spec-First** | Specs precede development but may be abandoned | Source of Truth | Basic |
| **Spec-Anchored** | Specs evolve continuously alongside code | Synchronized Partner | **Primary Target** |
| **Spec-as-Source** | Specs are sole human-edited artifacts; code is generated | Generated Byproduct | Future |

SpecMCP targets the **spec-anchored** level as the optimal balance for production systems.

---

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                     AI Coding Assistants                        │
│              (Claude, GPT, Cursor, OpenCode, etc.)              │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ MCP Protocol
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                        SpecMCP Server                           │
│                         (Go Binary)                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │  Workflow   │  │   Query     │  │     Task Management     │  │
│  │  Commands   │  │   Engine    │  │     & Assignment        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
                              │
                              │ REST API
                              ▼
┌─────────────────────────────────────────────────────────────────┐
│                     Emergent Graph API                          │
│                    (localhost:3002)                             │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐  │
│  │  Entities   │  │ Relationships│  │      Versioning        │  │
│  └─────────────┘  └─────────────┘  └─────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

---

## Entity Types

### Actors

Represent users, roles, or personas who interact with the system.

```yaml
Actor:
  properties:
    name: string              # "guest", "member", "admin"
    display_name: string      # "Guest User"
    description: text         # Role description and permissions
    tags: string[]            # domain:auth, lifecycle:stable
```

### Coding Agents

Represent developers or AI agents who implement tasks.

```yaml
CodingAgent:
  properties:
    name: string              # "alice", "ui-specialist-ai"
    display_name: string      # "Alice (Senior Frontend)"
    type: enum                # human | ai
    active: boolean           # Available for assignment
    skills: string[]          # ["react", "typescript", "go"]
    specialization: enum      # frontend | backend | fullstack | testing | devops
    instructions: text        # Agent-specific guidelines
    velocity_points_per_hour: number  # Measured performance
    tags: string[]
```

### Patterns

Reusable implementation patterns discovered in or applied to the codebase.

```yaml
Pattern:
  properties:
    name: string              # "optimistic-update"
    display_name: string      # "Optimistic Update Pattern"
    type: enum                # ui | api | data | state | error | auth | navigation | layout
    scope: enum               # core | project
    description: text         # What it does, when to use it
    example_code: text        # Abstract example implementation
    usage_guidance: text      # When to apply, considerations
    tags: string[]
```

**Pattern Types:**
- `ui` - Component patterns (form-wizard, infinite-scroll, skeleton-loading)
- `api` - Backend communication (rest-crud, graphql-query, polling, websocket)
- `data` - Data handling (optimistic-update, cache-invalidation, pagination)
- `state` - State management (local-first, derived-state, undo-redo)
- `error` - Error handling (retry-with-backoff, graceful-degradation, error-boundary)
- `auth` - Authentication/authorization (rbac, token-refresh, session-timeout)
- `navigation` - Routing patterns (deep-link, breadcrumb, wizard-flow)
- `layout` - Layout patterns (master-detail, dashboard-grid, responsive-breakpoint)

### Constitution

Project-wide non-negotiable principles that all Changes must adhere to.
Inspired by GitHub Spec Kit's "constitution" pattern - encodes architectural 
patterns, security guardrails, and testing requirements.

```yaml
Constitution:
  properties:
    name: string              # "project-constitution"
    version: string           # "1.0.0"
    principles: text          # High-level architectural principles
    guardrails: string[]      # Non-negotiable rules: ["no-orm", "all-endpoints-authenticated"]
    testing_requirements: text # Required testing standards
    security_requirements: text # Security guardrails
    patterns_required: string[] # Patterns that MUST be used for certain contexts
    patterns_forbidden: string[] # Patterns that MUST NOT be used
    tags: string[]
```

**Example Constitution Rules:**
- "All API endpoints MUST use authentication middleware"
- "Database access MUST go through repository pattern"
- "All user inputs MUST be validated at the boundary"
- "No direct DOM manipulation outside React components"

### TestCase

Links Scenarios to executable test files for validation.
Enables CI integration and verification that specifications are actually tested.

```yaml
TestCase:
  properties:
    name: string              # "test-valid-login"
    test_file: string         # "tests/auth/login.test.ts"
    test_function: string     # "testValidCredentials" (optional)
    test_framework: enum      # jest | pytest | go-test | vitest | playwright
    status: enum              # untested | passing | failing | skipped
    last_run_at: timestamp    # When test was last executed
    coverage_percent: number  # Code coverage percentage (optional)
    tags: string[]
```

### APIContract

Machine-readable API definitions that complement human-readable Specs.
Addresses the "AI-API Gap" - APIs designed for machine consumption.

```yaml
APIContract:
  properties:
    name: string              # "user-api-contract"
    format: enum              # openapi | asyncapi | typespec | smithy | graphql | grpc
    version: string           # "3.1.0" (spec version)
    file_path: string         # "api/openapi.yaml"
    base_url: string          # "https://api.example.com/v1" (optional)
    description: text         # What this contract covers
    auto_generated: boolean   # True if generated from code
    last_validated_at: timestamp # When contract was last validated against implementation
    validation_status: enum   # valid | invalid | unknown
    tags: string[]
```

**Supported Formats:**
- `openapi` - REST APIs (OpenAPI 3.x)
- `asyncapi` - Event-driven (Kafka, MQTT, WebSockets)
- `typespec` - Microsoft's high-level DSL
- `smithy` - Amazon's protocol-agnostic modeling
- `graphql` - GraphQL schemas
- `grpc` - Protocol Buffers definitions

### Change Management

Following the OpenSpec model, a Change contains four artifacts: Proposal (why), Specs (what), Design (how), and Tasks (steps).

```
Change
├── has_proposal → Proposal (1:1)        # Intent: why, scope, impact
│
├── has_spec → Spec (1:N)                # Domain specs like "auth", "payments"
│               └── has_requirement → Requirement (1:N)
│                                     └── has_scenario → Scenario (1:N)
│
├── has_design → Design (1:1)            # Technical approach
│
└── has_task → Task (1:N)                # Implementation steps
```

#### Change

Container for a feature, bug fix, or refactoring effort.

```yaml
Change:
  properties:
    name: string              # "add-user-permissions"
    status: enum              # active | archived
    base_commit: string       # Git commit when change started
    tags: string[]
```

#### Proposal

The **intent** of a change: why we're doing this and what's in scope.
Does NOT contain requirements (those go in Specs).

```yaml
Proposal:
  properties:
    intent: text              # Problem statement, motivation (the "why")
    scope: text               # What's in scope and out of scope
    impact: text              # Affected areas, risks, considerations
    tags: string[]
```

#### Spec

A domain-specific specification container (like `auth/`, `payments/`, `ui/`).
Contains requirements and their scenarios.

```yaml
Spec:
  properties:
    name: string              # "auth", "payments", "ui-theme"
    domain: string            # Domain area this spec covers
    purpose: text             # High-level description of this spec's domain
    delta_type: enum          # added | modified | removed (for change tracking)
    tags: string[]
```

#### Requirement

A specific behavior the system must have. Lives under a Spec.
Uses RFC 2119 keywords (MUST, SHALL, SHOULD, MAY).

```yaml
Requirement:
  properties:
    name: string              # "user-authentication", "session-expiration"
    description: text         # The system SHALL issue a JWT token upon successful login
    strength: enum            # MUST | SHALL | SHOULD | MAY
    delta_type: enum          # added | modified | removed (for change tracking)
    tags: string[]
```

#### Scenario

A concrete example of a requirement in action. Lives under a Requirement.
Scenarios are testable - you could write an automated test for each.

```yaml
Scenario:
  properties:
    name: string              # "valid-credentials", "invalid-credentials"
    title: string             # "Valid Credentials Login"
    given: text               # Precondition: "a user with valid credentials"
    when: text                # Action: "the user submits login form"  
    then: text                # Expected: "a JWT token is returned"
    and_also: string[]        # Additional outcomes: ["user is redirected to dashboard"]
    tags: string[]
```

#### ScenarioStep

For complex scenarios that need step-by-step breakdown.
Optional - simple scenarios may not need steps.

```yaml
ScenarioStep:
  properties:
    sequence: integer         # 1, 2, 3, ...
    description: text         # What happens in this step
    tags: string[]
```

#### Design

Technical approach and architecture decisions.

```yaml
Design:
  properties:
    approach: text            # Technical approach, high-level design
    decisions: text           # Key architecture decisions and rationale
    data_flow: text           # How data moves through the system
    file_changes: string[]    # Expected files to create/modify
    tags: string[]
```

#### Task

An implementation task with tracking and artifact production.

```yaml
Task:
  properties:
    number: string            # T1, T2, T3, ...
    description: text         # What to implement
    task_type: enum           # spec | context | component | action | pattern
    status: enum              # pending | in_progress | completed | blocked
    complexity_points: integer # 1-10 complexity estimate
    started_at: timestamp     # When work began
    completed_at: timestamp   # When work finished
    actual_hours: number      # Calculated from start/complete
    artifacts: string[]       # Paths to deliverables produced
    verification_method: enum # manual | automated | screenshot | test
    verification_notes: text  # Notes on how completion was verified
    tags: string[]
```

**Artifacts**: Tangible deliverables produced by the task (files created, screenshots, test results).
Following Google Antigravity's "Artifacts over Logs" principle.

### Structural (from Code Analysis)

#### Context

A screen, modal, or interaction surface.

```yaml
Context:
  properties:
    name: string              # "user-management-screen"
    display_name: string      # "User Management Screen"
    type: enum                # screen | modal | panel | notification | external
    scope: enum               # internal | external
    platform: string[]        # ["web", "mobile"]
    description: text         # Purpose and behavior
    file_path: string         # Path to implementation
    tags: string[]
```

#### UIComponent

A reusable UI component.

```yaml
UIComponent:
  properties:
    name: string              # "user-list"
    display_name: string      # "User List Component"
    type: enum                # primitive | composite | layout | container
    file_path: string         # Path to implementation
    description: text         # Purpose and usage
    tags: string[]
```

#### Action

A user action or system operation.

```yaml
Action:
  properties:
    name: string              # "update-user-role"
    display_label: string     # "Update Role"
    type: enum                # navigation | mutation | trigger | toggle | external
    description: text         # What the action does
    handler_path: string      # Path to handler implementation
    tags: string[]
```

### Sync

Track synchronization between graph and codebase.

```yaml
GraphSync:
  properties:
    last_synced_commit: string    # Git commit hash
    last_synced_at: timestamp     # When sync occurred
    status: enum                  # synced | stale | syncing | error
    tags: string[]
```

---

## Relationship Types

### Actor Relationships

```yaml
inherits_from:      Actor -> Actor
# Guest inherits_from Member (Member has all Guest permissions plus more)
```

### Pattern Relationships

```yaml
uses_pattern:       Context -> Pattern
uses_pattern:       UIComponent -> Pattern
uses_pattern:       Action -> Pattern
uses_pattern:       ScenarioStep -> Pattern

extends_pattern:    Pattern -> Pattern
# Project-specific pattern extends core pattern
```

### Change Structure

Following OpenSpec's artifact model:

```yaml
# Change contains all artifacts
has_proposal:       Change -> Proposal         # 1:1 - Intent (why/scope)
has_spec:           Change -> Spec             # 1:N - Domain specs (what)
has_design:         Change -> Design           # 1:1 - Technical approach (how)
has_task:           Change -> Task             # 1:N - Implementation steps

# Spec contains requirements
has_requirement:    Spec -> Requirement        # 1:N - Requirements in this domain

# Requirement contains scenarios (examples)
has_scenario:       Requirement -> Scenario    # 1:N - Concrete examples of requirement
```

### Scenario Relationships

```yaml
executed_by:        Scenario -> Actor
# Relationship properties: conditions (map for plan, trial_status, etc.)

has_step:           Scenario -> ScenarioStep   # 1:N (optional, for complex scenarios)
variant_of:         Scenario -> Scenario       # Alternative path
```

### Step Connections

```yaml
occurs_in:          ScenarioStep -> Context
performs:           ScenarioStep -> Action
```

### Context & Component Relationships

```yaml
composed_of:        UIComponent -> UIComponent  # Component hierarchy
uses_component:     Context -> UIComponent      # Context uses component
nested_in:          Context -> Context          # Modal nested in screen
```

### Action Relationships

```yaml
available_in:       Action -> Context           # N:M
navigates_to:       Action -> Context           # Navigation target
```

### Task Relationships

```yaml
has_subtask:        Task -> Task               # T1 has_subtask T2
blocks:             Task -> Task               # T4 blocks T2 (dependency)
# Emergent auto-creates reverse "blocked_by"

implements:         Task -> Spec
implements:         Task -> Context
implements:         Task -> UIComponent
implements:         Task -> Action
implements:         Task -> Pattern

assigned_to:        Task -> CodingAgent        # Who's working on it
```

### Constitution Relationships

```yaml
governed_by:        Change -> Constitution     # Change must adhere to constitution
requires_pattern:   Constitution -> Pattern    # Patterns mandated by constitution
forbids_pattern:    Constitution -> Pattern    # Patterns forbidden by constitution
```

### Test Relationships

```yaml
tested_by:          Scenario -> TestCase       # Scenario has executable test
tests:              TestCase -> Scenario       # TestCase validates scenario
```

### Contract Relationships

```yaml
has_contract:       Spec -> APIContract        # Spec has machine-readable contract
implements_contract: Context -> APIContract    # Context implements contract
implements_contract: Action -> APIContract     # Action implements contract endpoint
```

### Ownership Relationships

```yaml
owned_by:           Spec -> CodingAgent        # Who is responsible for this spec
owned_by:           Context -> CodingAgent     # Who is responsible for this context
owned_by:           UIComponent -> CodingAgent # Who is responsible for this component
owned_by:           Action -> CodingAgent      # Who is responsible for this action
```

---

## Tagging System

All entities support `tags: string[]` for flexible categorization.

### Tag Conventions

```
domain:<value>      # Business domain
platform:<value>    # Target platform
lifecycle:<value>   # Feature lifecycle
```

### Domain Tags
- `domain:auth` - Authentication/authorization
- `domain:billing` - Payment and billing
- `domain:onboarding` - User onboarding
- `domain:settings` - Configuration/settings
- `domain:analytics` - Reporting/analytics

### Platform Tags
- `platform:web` - Web application
- `platform:mobile` - Mobile (iOS/Android)
- `platform:desktop` - Desktop application
- `platform:api` - Backend API

### Lifecycle Tags
- `lifecycle:experimental` - New, untested
- `lifecycle:stable` - Production-ready
- `lifecycle:deprecated` - Being phased out

---

## Task Management System

### Complexity Points

Tasks are estimated using 1-10 complexity points:

| Points | Description | Example |
|--------|-------------|---------|
| 1-2 | Trivial | Simple button, text change |
| 3-4 | Simple | Basic form, navigation link |
| 5-6 | Moderate | List with filters, modal form |
| 7-8 | Complex | Dashboard widget, data table |
| 9-10 | Very Complex | Multi-step wizard, real-time sync |

### Scenario Points

Scenario complexity is the sum of all subtask points:

```
Scenario "Admin manages users" = 25 total points
├── T2: UserMgmtScreen (5 points) [completed]
├── T5: UserList (4 points) [completed]
├── T6: PermissionPanel (6 points) [in_progress]
├── T7: ActionButtons (2 points) [pending]
├── T3: update-user-role (4 points) [pending]
└── T4: audit-change (4 points) [pending]

Progress: 9/25 points = 36% complete
```

### Build Order

Tasks follow a bottom-up dependency order:

```
Components → Contexts → Actions → Scenarios
```

Example dependency chain:
```
T5 (UserList) ──────┐
T6 (PermissionPanel)├─blocks─→ T2 (UserMgmtScreen) ─blocks─→ T3 (update-role) ─blocks─→ T1 (Scenario)
T7 (ActionButtons) ─┘
```

### Parallel Execution

**Available Tasks**: Unblocked + Unassigned + Pending

Multiple available tasks = parallel execution opportunity:
```
Available Tasks:
  T5: UserList [4 points] - skills: react, typescript
  T6: PermissionPanel [6 points] - skills: react, typescript
  T7: ActionButtons [2 points] - skills: react

Parallel Capacity: 3 tasks
```

### Agent Assignment

Match tasks to agents by skills and workload:

```yaml
Task T5 (UserList):
  required_skills: [react, typescript]
  
Suitable Agents:
  - ui-specialist-ai (skills match, 8 points in progress)
  - alice (skills match, 0 points in progress) ← Best choice
```

### Velocity Tracking

Track agent performance to improve estimates:

```
Alice's Performance:
  - T5: 4 points in 3.2 hours = 1.25 points/hour
  - T3: 6 points in 4.8 hours = 1.25 points/hour
  
Average Velocity: 1.25 points/hour

Prediction for T6 (6 points): ~4.8 hours
```

---

## MCP Tools

### Workflow Commands

```yaml
spec_new:
  description: "Create a new change with proposal"
  parameters:
    - name: string
    - why: string
    - what: string
  returns: "Change entity ID"

spec_artifact:
  description: "Add artifact to change (requirement, scenario, design, etc.)"
  parameters:
    - change_id: string
    - artifact_type: string
    - content: object
  returns: "Artifact entity ID"

spec_archive:
  description: "Archive completed change"
  parameters:
    - change_id: string
```

### Sync Commands

```yaml
spec_sync_status:
  description: "Check if graph is in sync with git"
  returns: "Sync status and commit comparison"

spec_sync:
  description: "Sync graph with current codebase state"
  parameters:
    - commit: string (optional, defaults to HEAD)
  returns: "Sync results with detected changes"
```

### Query Commands

```yaml
spec_get_context:
  description: "Get context details and relationships"
  parameters:
    - name: string
  returns: "Context with components, actions, patterns"

spec_get_component:
  description: "Get component details and usage"
  parameters:
    - name: string
  returns: "Component with contexts, patterns, dependencies"

spec_get_scenario:
  description: "Get scenario with all steps and dependencies"
  parameters:
    - name: string
  returns: "Scenario with steps, actors, requirements"

spec_impact_analysis:
  description: "What's affected if we change this entity"
  parameters:
    - entity_type: string
    - entity_name: string
  returns: "Affected scenarios, tasks, components"
```

### Task Commands

```yaml
spec_get_available_tasks:
  description: "Get unblocked, unassigned tasks"
  returns: "Tasks with complexity, suitable agents"

spec_get_parallel_capacity:
  description: "How many tasks can run in parallel"
  returns: "Count and task list"

spec_assign_task:
  description: "Assign task to coding agent"
  parameters:
    - task_number: string
    - agent_name: string
  returns: "Updated task"

spec_complete_task:
  description: "Mark task completed, unlock dependents"
  parameters:
    - task_number: string
  returns: "Newly available tasks"

spec_get_scenario_progress:
  description: "Calculate completion percentage"
  parameters:
    - scenario_name: string
  returns: "Points completed/total, estimated hours"

spec_generate_tasks:
  description: "Generate task tree for scenario"
  parameters:
    - scenario_name: string
  returns: "Task hierarchy with dependencies"

spec_get_critical_path:
  description: "Find longest dependency chain"
  parameters:
    - scenario_name: string
  returns: "Critical path tasks"
```

### Pattern Commands

```yaml
spec_get_patterns:
  description: "List all patterns by type"
  parameters:
    - type: string (optional)
    - scope: string (optional)
  returns: "Pattern list"

spec_suggest_patterns:
  description: "AI suggests patterns for entity"
  parameters:
    - entity_type: string
    - entity_name: string
  returns: "Suggested patterns with confidence"

spec_apply_pattern:
  description: "Link pattern to entity"
  parameters:
    - pattern_name: string
    - entity_type: string
    - entity_name: string
```

---

## Workflow

### OpenSpec Alignment

SpecMCP follows the OpenSpec workflow model:

```
proposal ──────► specs ──────► design ──────► tasks ──────► implement
    │               │             │              │
   why            what           how          steps
 + scope       (domain        (technical    (implementation
               requirements   approach)       checklist)
               + scenarios)
```

### 1. Initial Code Analysis

```
1. Run spec_sync to analyze codebase
2. Extract Contexts (screens, modals, panels)
3. Extract UIComponents (React components, etc.)
4. Extract Actions (handlers, API calls)
5. Auto-detect Patterns with confirmation
6. Tag entities with domain/platform/lifecycle
7. Store GraphSync with current commit
```

### 2. Feature Development

```
1. spec_new - Create change with proposal (intent, scope, impact)
2. spec_add_spec - Add domain specs with requirements and scenarios
3. spec_add_design - Add technical approach
4. spec_generate_tasks - Create task tree from specs
5. spec_get_available_tasks - Get starting tasks
6. spec_assign_task - Assign to agents
7. Implement task
8. spec_complete_task - Mark done, unlock next
9. Repeat 5-8 until all tasks complete
10. spec_archive - Archive completed change
```

### 3. Parallel Development

```
1. Agent A: spec_get_available_tasks → picks T5
2. Agent B: spec_get_available_tasks → picks T6
3. Agent C: spec_get_available_tasks → picks T7
4. All work in parallel
5. Agent A: spec_complete_task(T5)
6. Agent B: spec_complete_task(T6)
7. Agent C: spec_complete_task(T7)
8. T2 becomes available (was blocked by T5,T6,T7)
9. Agent A: picks T2
```

---

## Configuration

### Emergent Connection

```yaml
emergent:
  url: "http://localhost:3002"
  project_id: "b697f070-f13a-423b-8678-04978fd39e21"
  api_key: "${EMERGENT_API_KEY}"
```

### MCP Server

```yaml
specmcp:
  name: "specmcp"
  version: "1.0.0"
  transport: "stdio"
```

---

## Future Considerations

1. **Multi-project support** - Work across related projects
2. **Branch-aware workflows** - Track changes per git branch
3. **Test integration** - Link scenarios to test files
4. **CI/CD integration** - Update task status from pipelines
5. **Metrics dashboard** - Visualize velocity, progress, patterns

---

## Appendix: Entity Diagram

```
                                  ┌─────────────┐
                                  │   Actor     │
                                  └──────┬──────┘
                                         │ inherits_from
                                         ▼
                                  ┌─────────────┐
                                  │   Actor     │
                                  └─────────────┘

┌─────────────┐                   ┌─────────────┐
│   Pattern   │◄── extends ──────│   Pattern   │
│   (core)    │                   │  (project)  │
└──────┬──────┘                   └─────────────┘
       │
       │ uses_pattern
       ▼
┌─────────────┐   uses_component  ┌─────────────┐  composed_of   ┌─────────────┐
│   Context   │◄─────────────────│ UIComponent │◄───────────────│ UIComponent │
└──────┬──────┘                   └─────────────┘                └─────────────┘
       │
       │ available_in
       ▼
┌─────────────┐
│   Action    │
└─────────────┘


                    ════════════════════════════════════════════════════════
                                    CHANGE MANAGEMENT (OpenSpec Model)
                    ════════════════════════════════════════════════════════

┌─────────────┐
│   Change    │─────────────────────────────────────────────────────────────────┐
└──────┬──────┘                                                                 │
       │                                                                        │
       ├── has_proposal ──►┌─────────────┐                                      │
       │                   │  Proposal   │  Intent: why, scope, impact          │
       │                   └─────────────┘                                      │
       │                                                                        │
       ├── has_spec ──────►┌─────────────┐  has_requirement  ┌─────────────┐    │
       │                   │    Spec     │──────────────────►│ Requirement │    │
       │                   │  (domain)   │                   └──────┬──────┘    │
       │                   └─────────────┘                          │           │
       │                                                            │           │
       │                                           has_scenario     │           │
       │                                                            ▼           │
       │                                                     ┌─────────────┐    │
       │                                                     │  Scenario   │    │
       │                                                     │ (example)   │    │
       │                                                     └──────┬──────┘    │
       │                                                            │           │
       │                                              executed_by   │           │
       │                                                            ▼           │
       │                                                     ┌─────────────┐    │
       │                                                     │    Actor    │    │
       │                                                     └─────────────┘    │
       │                                                                        │
       ├── has_design ────►┌─────────────┐                                      │
       │                   │   Design    │  Technical approach                  │
       │                   └─────────────┘                                      │
       │                                                                        │
       └── has_task ──────►┌─────────────┐  has_subtask    ┌─────────────┐      │
                           │    Task     │────────────────►│    Task     │      │
                           └──────┬──────┘                 └─────────────┘      │
                                  │                                             │
                                  │ assigned_to                                 │
                                  ▼                                             │
                           ┌─────────────┐                                      │
                           │ CodingAgent │                                      │
                           └─────────────┘                                      │
                                                                                │
────────────────────────────────────────────────────────────────────────────────┘

Task Dependencies:

┌─────────────┐    blocks      ┌─────────────┐    blocks      ┌─────────────┐
│    Task     │───────────────►│    Task     │───────────────►│    Task     │
│ (component) │                │  (context)  │                │   (spec)    │
└─────────────┘                └─────────────┘                └─────────────┘
```

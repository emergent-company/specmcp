{
  "name": "SpecMCP",
  "version": "1.0.0",
  "description": "Spec-driven development workflow template pack. Defines entity types and relationships for managing specifications, requirements, scenarios, tasks, patterns, and codebase structure in a knowledge graph.",
  "author": "Diane",
  "object_type_schemas": {
    "Actor": {
      "type": "object",
      "description": "A user, role, or persona who interacts with the system. Used in scenarios to describe who performs actions.",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier for the actor (e.g. 'guest', 'member', 'admin')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'Guest User')"
        },
        "description": {
          "type": "string",
          "description": "Role description, permissions, and behavioral characteristics"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags (e.g. domain:auth, platform:web, lifecycle:stable)"
        }
      }
    },
    "CodingAgent": {
      "type": "object",
      "description": "A developer or AI agent who implements tasks. Tracks skills, specialization, and velocity for task assignment.",
      "required": ["name", "type"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'alice', 'ui-specialist-ai')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'Alice (Senior Frontend)')"
        },
        "type": {
          "type": "string",
          "enum": ["human", "ai"],
          "description": "Whether this is a human developer or AI agent"
        },
        "active": {
          "type": "boolean",
          "description": "Whether the agent is available for task assignment",
          "default": true
        },
        "skills": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Technical skills (e.g. ['react', 'typescript', 'go'])"
        },
        "specialization": {
          "type": "string",
          "enum": ["frontend", "backend", "fullstack", "testing", "devops"],
          "description": "Primary area of expertise"
        },
        "instructions": {
          "type": "string",
          "description": "Agent-specific guidelines and working preferences"
        },
        "velocity_points_per_hour": {
          "type": "number",
          "minimum": 0,
          "description": "Measured performance in complexity points per hour"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Pattern": {
      "type": "object",
      "description": "A reusable implementation pattern discovered in or applied to the codebase. Patterns can be core (built-in) or project-specific.",
      "required": ["name", "type"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'optimistic-update')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'Optimistic Update Pattern')"
        },
        "type": {
          "type": "string",
          "enum": ["ui", "api", "data", "state", "error", "auth", "navigation", "layout"],
          "description": "Pattern category"
        },
        "scope": {
          "type": "string",
          "enum": ["core", "project"],
          "description": "Whether this is a built-in core pattern or project-specific"
        },
        "description": {
          "type": "string",
          "description": "What the pattern does and when to use it"
        },
        "example_code": {
          "type": "string",
          "description": "Abstract example implementation"
        },
        "usage_guidance": {
          "type": "string",
          "description": "When to apply this pattern and considerations"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Constitution": {
      "type": "object",
      "description": "Project-wide non-negotiable principles that all Changes must adhere to. Encodes architectural patterns, security guardrails, and testing requirements.",
      "required": ["name", "version"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'project-constitution')"
        },
        "version": {
          "type": "string",
          "description": "Semantic version (e.g. '1.0.0')"
        },
        "principles": {
          "type": "string",
          "description": "High-level architectural principles"
        },
        "guardrails": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Non-negotiable rules (e.g. 'no-orm', 'all-endpoints-authenticated')"
        },
        "testing_requirements": {
          "type": "string",
          "description": "Required testing standards"
        },
        "security_requirements": {
          "type": "string",
          "description": "Security guardrails and requirements"
        },
        "patterns_required": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Pattern names that MUST be used for certain contexts"
        },
        "patterns_forbidden": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Pattern names that MUST NOT be used"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Change": {
      "type": "object",
      "description": "Container for a feature, bug fix, or refactoring effort. Contains four artifacts: Proposal (why), Specs (what), Design (how), Tasks (steps).",
      "required": ["name", "status"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'add-user-permissions')"
        },
        "status": {
          "type": "string",
          "enum": ["active", "archived"],
          "description": "Change lifecycle status"
        },
        "base_commit": {
          "type": "string",
          "description": "Git commit SHA when the change started"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Proposal": {
      "type": "object",
      "description": "The intent of a change: why we're doing this and what's in scope. Does NOT contain requirements (those go in Specs).",
      "required": ["intent"],
      "properties": {
        "intent": {
          "type": "string",
          "description": "Problem statement and motivation (the 'why')"
        },
        "scope": {
          "type": "string",
          "description": "What's in scope and out of scope"
        },
        "impact": {
          "type": "string",
          "description": "Affected areas, risks, and considerations"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Spec": {
      "type": "object",
      "description": "A domain-specific specification container (e.g. auth, payments, ui). Contains requirements and their scenarios.",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'auth', 'payments', 'ui-theme')"
        },
        "domain": {
          "type": "string",
          "description": "Domain area this spec covers"
        },
        "purpose": {
          "type": "string",
          "description": "High-level description of this spec's domain"
        },
        "delta_type": {
          "type": "string",
          "enum": ["added", "modified", "removed"],
          "description": "Type of change for change tracking"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Requirement": {
      "type": "object",
      "description": "A specific behavior the system must have. Lives under a Spec. Uses RFC 2119 keywords (MUST, SHALL, SHOULD, MAY).",
      "required": ["name", "description"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-authentication', 'session-expiration')"
        },
        "description": {
          "type": "string",
          "description": "The requirement statement (e.g. 'The system SHALL issue a JWT token upon successful login')"
        },
        "strength": {
          "type": "string",
          "enum": ["MUST", "SHALL", "SHOULD", "MAY"],
          "description": "RFC 2119 requirement strength"
        },
        "delta_type": {
          "type": "string",
          "enum": ["added", "modified", "removed"],
          "description": "Type of change for change tracking"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Scenario": {
      "type": "object",
      "description": "A concrete example of a requirement in action. Testable — you could write an automated test for each scenario.",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'valid-credentials', 'invalid-credentials')"
        },
        "title": {
          "type": "string",
          "description": "Human-readable title (e.g. 'Valid Credentials Login')"
        },
        "given": {
          "type": "string",
          "description": "Precondition (e.g. 'a user with valid credentials')"
        },
        "when": {
          "type": "string",
          "description": "Action (e.g. 'the user submits login form')"
        },
        "then": {
          "type": "string",
          "description": "Expected outcome (e.g. 'a JWT token is returned')"
        },
        "and_also": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Additional expected outcomes"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "ScenarioStep": {
      "type": "object",
      "description": "A step in a complex scenario that needs step-by-step breakdown. Optional — simple scenarios may not need steps.",
      "required": ["sequence", "description"],
      "properties": {
        "sequence": {
          "type": "integer",
          "minimum": 1,
          "description": "Step order (1, 2, 3, ...)"
        },
        "description": {
          "type": "string",
          "description": "What happens in this step"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Design": {
      "type": "object",
      "description": "Technical approach and architecture decisions for a change.",
      "properties": {
        "approach": {
          "type": "string",
          "description": "Technical approach and high-level design"
        },
        "decisions": {
          "type": "string",
          "description": "Key architecture decisions and rationale"
        },
        "data_flow": {
          "type": "string",
          "description": "How data moves through the system"
        },
        "file_changes": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Expected files to create or modify"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Task": {
      "type": "object",
      "description": "An implementation task with tracking, dependency management, and artifact production.",
      "required": ["number", "description", "status"],
      "properties": {
        "number": {
          "type": "string",
          "description": "Task identifier (e.g. 'T1', 'T2', 'T3')"
        },
        "description": {
          "type": "string",
          "description": "What to implement"
        },
        "task_type": {
          "type": "string",
          "enum": ["spec", "context", "component", "action", "pattern"],
          "description": "What kind of entity this task implements"
        },
        "status": {
          "type": "string",
          "enum": ["pending", "in_progress", "completed", "blocked"],
          "description": "Current task status"
        },
        "complexity_points": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10,
          "description": "Complexity estimate (1-10 points, NOT hours)"
        },
        "started_at": {
          "type": "string",
          "format": "date-time",
          "description": "When work began"
        },
        "completed_at": {
          "type": "string",
          "format": "date-time",
          "description": "When work finished"
        },
        "actual_hours": {
          "type": "number",
          "minimum": 0,
          "description": "Actual hours spent (calculated from started_at/completed_at)"
        },
        "artifacts": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Paths to deliverables produced"
        },
        "verification_method": {
          "type": "string",
          "enum": ["manual", "automated", "screenshot", "test"],
          "description": "How task completion was verified"
        },
        "verification_notes": {
          "type": "string",
          "description": "Notes on how completion was verified"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "TestCase": {
      "type": "object",
      "description": "Links scenarios to executable test files for validation. Enables CI integration and verification.",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'test-valid-login')"
        },
        "test_file": {
          "type": "string",
          "description": "Path to the test file (e.g. 'tests/auth/login.test.ts')"
        },
        "test_function": {
          "type": "string",
          "description": "Specific test function name (optional)"
        },
        "test_framework": {
          "type": "string",
          "enum": ["jest", "pytest", "go-test", "vitest", "playwright"],
          "description": "Test framework used"
        },
        "status": {
          "type": "string",
          "enum": ["untested", "passing", "failing", "skipped"],
          "description": "Current test status"
        },
        "last_run_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the test was last executed"
        },
        "coverage_percent": {
          "type": "number",
          "minimum": 0,
          "maximum": 100,
          "description": "Code coverage percentage"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "APIContract": {
      "type": "object",
      "description": "Machine-readable API definition that complements human-readable Specs. Addresses the AI-API gap.",
      "required": ["name", "format"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-api-contract')"
        },
        "format": {
          "type": "string",
          "enum": ["openapi", "asyncapi", "typespec", "smithy", "graphql", "grpc"],
          "description": "Contract format"
        },
        "version": {
          "type": "string",
          "description": "Spec version (e.g. '3.1.0')"
        },
        "file_path": {
          "type": "string",
          "description": "Path to the contract file (e.g. 'api/openapi.yaml')"
        },
        "base_url": {
          "type": "string",
          "format": "uri",
          "description": "API base URL"
        },
        "description": {
          "type": "string",
          "description": "What this contract covers"
        },
        "auto_generated": {
          "type": "boolean",
          "description": "Whether the contract was generated from code"
        },
        "last_validated_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the contract was last validated against implementation"
        },
        "validation_status": {
          "type": "string",
          "enum": ["valid", "invalid", "unknown"],
          "description": "Current validation status"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Context": {
      "type": "object",
      "description": "A screen, modal, panel, or interaction surface in the application. Extracted from codebase during sync.",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-management-screen')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'User Management Screen')"
        },
        "type": {
          "type": "string",
          "enum": ["screen", "modal", "panel", "notification", "external"],
          "description": "Kind of interaction surface"
        },
        "scope": {
          "type": "string",
          "enum": ["internal", "external"],
          "description": "Whether internal or external facing"
        },
        "platform": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Target platforms (e.g. ['web', 'mobile'])"
        },
        "description": {
          "type": "string",
          "description": "Purpose and behavior"
        },
        "file_path": {
          "type": "string",
          "description": "Path to implementation file"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "UIComponent": {
      "type": "object",
      "description": "A reusable UI component. Extracted from codebase during sync.",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-list')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'User List Component')"
        },
        "type": {
          "type": "string",
          "enum": ["primitive", "composite", "layout", "container"],
          "description": "Component category"
        },
        "file_path": {
          "type": "string",
          "description": "Path to implementation file"
        },
        "description": {
          "type": "string",
          "description": "Purpose and usage"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "Action": {
      "type": "object",
      "description": "A user action or system operation (navigation, mutation, trigger, etc.).",
      "required": ["name"],
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'update-user-role')"
        },
        "display_label": {
          "type": "string",
          "description": "Human-readable label (e.g. 'Update Role')"
        },
        "type": {
          "type": "string",
          "enum": ["navigation", "mutation", "trigger", "toggle", "external"],
          "description": "Action category"
        },
        "description": {
          "type": "string",
          "description": "What the action does"
        },
        "handler_path": {
          "type": "string",
          "description": "Path to handler implementation"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    },
    "GraphSync": {
      "type": "object",
      "description": "Tracks synchronization state between the Emergent graph and the codebase.",
      "required": ["status"],
      "properties": {
        "last_synced_commit": {
          "type": "string",
          "description": "Git commit hash of last sync"
        },
        "last_synced_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the last sync occurred"
        },
        "status": {
          "type": "string",
          "enum": ["synced", "stale", "syncing", "error"],
          "description": "Current sync status"
        },
        "tags": {
          "type": "array",
          "items": { "type": "string" },
          "description": "Namespaced tags"
        }
      }
    }
  },
  "relationship_type_schemas": {
    "inherits_from": {
      "description": "Actor inherits permissions and capabilities from another actor",
      "sourceTypes": ["Actor"],
      "targetTypes": ["Actor"],
      "cardinality": "many-to-one"
    },
    "uses_pattern": {
      "description": "Entity uses a reusable implementation pattern",
      "sourceTypes": ["Context", "UIComponent", "Action", "ScenarioStep"],
      "targetTypes": ["Pattern"],
      "cardinality": "many-to-many"
    },
    "extends_pattern": {
      "description": "Project-specific pattern extends a core pattern",
      "sourceTypes": ["Pattern"],
      "targetTypes": ["Pattern"],
      "cardinality": "many-to-one"
    },
    "has_proposal": {
      "description": "Change has a proposal describing intent, scope, and impact",
      "sourceTypes": ["Change"],
      "targetTypes": ["Proposal"],
      "cardinality": "one-to-one"
    },
    "has_spec": {
      "description": "Change has a domain-specific specification",
      "sourceTypes": ["Change"],
      "targetTypes": ["Spec"],
      "cardinality": "one-to-many"
    },
    "has_design": {
      "description": "Change has a technical design",
      "sourceTypes": ["Change"],
      "targetTypes": ["Design"],
      "cardinality": "one-to-one"
    },
    "has_task": {
      "description": "Change has an implementation task",
      "sourceTypes": ["Change"],
      "targetTypes": ["Task"],
      "cardinality": "one-to-many"
    },
    "has_requirement": {
      "description": "Spec contains a requirement",
      "sourceTypes": ["Spec"],
      "targetTypes": ["Requirement"],
      "cardinality": "one-to-many"
    },
    "has_scenario": {
      "description": "Requirement has a concrete scenario example",
      "sourceTypes": ["Requirement"],
      "targetTypes": ["Scenario"],
      "cardinality": "one-to-many"
    },
    "executed_by": {
      "description": "Scenario is executed by an actor",
      "sourceTypes": ["Scenario"],
      "targetTypes": ["Actor"],
      "cardinality": "many-to-one"
    },
    "has_step": {
      "description": "Scenario has an ordered step",
      "sourceTypes": ["Scenario"],
      "targetTypes": ["ScenarioStep"],
      "cardinality": "one-to-many"
    },
    "variant_of": {
      "description": "Scenario is an alternative path of another scenario",
      "sourceTypes": ["Scenario"],
      "targetTypes": ["Scenario"],
      "cardinality": "many-to-one"
    },
    "occurs_in": {
      "description": "Scenario step occurs in a context (screen, modal, etc.)",
      "sourceTypes": ["ScenarioStep"],
      "targetTypes": ["Context"],
      "cardinality": "many-to-one"
    },
    "performs": {
      "description": "Scenario step performs an action",
      "sourceTypes": ["ScenarioStep"],
      "targetTypes": ["Action"],
      "cardinality": "many-to-one"
    },
    "composed_of": {
      "description": "UI component is composed of child components",
      "sourceTypes": ["UIComponent"],
      "targetTypes": ["UIComponent"],
      "cardinality": "many-to-many"
    },
    "uses_component": {
      "description": "Context uses a UI component",
      "sourceTypes": ["Context"],
      "targetTypes": ["UIComponent"],
      "cardinality": "many-to-many"
    },
    "nested_in": {
      "description": "Context is nested inside another context (e.g. modal inside screen)",
      "sourceTypes": ["Context"],
      "targetTypes": ["Context"],
      "cardinality": "many-to-one"
    },
    "available_in": {
      "description": "Action is available in a context",
      "sourceTypes": ["Action"],
      "targetTypes": ["Context"],
      "cardinality": "many-to-many"
    },
    "navigates_to": {
      "description": "Action navigates to a target context",
      "sourceTypes": ["Action"],
      "targetTypes": ["Context"],
      "cardinality": "many-to-one"
    },
    "has_subtask": {
      "description": "Task has a subtask",
      "sourceTypes": ["Task"],
      "targetTypes": ["Task"],
      "cardinality": "one-to-many"
    },
    "blocks": {
      "description": "Task blocks another task (dependency). Emergent auto-creates inverse 'blocked_by'.",
      "sourceTypes": ["Task"],
      "targetTypes": ["Task"],
      "cardinality": "many-to-many",
      "inverseType": "blocked_by"
    },
    "blocked_by": {
      "description": "Task is blocked by another task (auto-created inverse of 'blocks')",
      "sourceTypes": ["Task"],
      "targetTypes": ["Task"],
      "cardinality": "many-to-many",
      "inverseType": "blocks"
    },
    "implements": {
      "description": "Task implements an entity (spec, context, component, action, or pattern)",
      "sourceTypes": ["Task"],
      "targetTypes": ["Spec", "Context", "UIComponent", "Action", "Pattern"],
      "cardinality": "many-to-many"
    },
    "assigned_to": {
      "description": "Task is assigned to a coding agent",
      "sourceTypes": ["Task"],
      "targetTypes": ["CodingAgent"],
      "cardinality": "many-to-one"
    },
    "governed_by": {
      "description": "Change must adhere to a constitution",
      "sourceTypes": ["Change"],
      "targetTypes": ["Constitution"],
      "cardinality": "many-to-one"
    },
    "requires_pattern": {
      "description": "Constitution mandates the use of a pattern",
      "sourceTypes": ["Constitution"],
      "targetTypes": ["Pattern"],
      "cardinality": "many-to-many"
    },
    "forbids_pattern": {
      "description": "Constitution forbids the use of a pattern",
      "sourceTypes": ["Constitution"],
      "targetTypes": ["Pattern"],
      "cardinality": "many-to-many"
    },
    "tested_by": {
      "description": "Scenario is validated by a test case",
      "sourceTypes": ["Scenario"],
      "targetTypes": ["TestCase"],
      "cardinality": "one-to-many"
    },
    "tests": {
      "description": "Test case validates a scenario",
      "sourceTypes": ["TestCase"],
      "targetTypes": ["Scenario"],
      "cardinality": "many-to-one"
    },
    "has_contract": {
      "description": "Spec has a machine-readable API contract",
      "sourceTypes": ["Spec"],
      "targetTypes": ["APIContract"],
      "cardinality": "one-to-many"
    },
    "implements_contract": {
      "description": "Entity implements an API contract endpoint",
      "sourceTypes": ["Context", "Action"],
      "targetTypes": ["APIContract"],
      "cardinality": "many-to-many"
    },
    "owned_by": {
      "description": "Entity is owned/maintained by a coding agent",
      "sourceTypes": ["Spec", "Context", "UIComponent", "Action"],
      "targetTypes": ["CodingAgent"],
      "cardinality": "many-to-one"
    }
  },
  "ui_configs": {},
  "extraction_prompts": {}
}

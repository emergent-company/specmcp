{
  "name": "SpecMCP",
  "version": "2.0.0",
  "description": "Spec-driven development workflow template pack. Defines entity types and relationships for managing specifications, requirements, scenarios, tasks, patterns, and codebase structure in a knowledge graph.",
  "author": "Diane",
  "object_type_schemas": [
    {
      "name": "Actor",
      "description": "A user, role, or persona who interacts with the system. Used in scenarios to describe who performs actions.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier for the actor (e.g. 'guest', 'member', 'admin')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'Guest User')"
        },
        "description": {
          "type": "string",
          "description": "Role description, permissions, and behavioral characteristics"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags (e.g. domain:auth, platform:web, lifecycle:stable)"
        }
      }
    },
    {
      "name": "Agent",
      "description": "An agent (human or AI) that performs tasks. Supports multiple agent types: coding, maintenance, research, testing, deployment, and analysis.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'alice', 'ui-specialist-ai')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'Alice (Senior Frontend)')"
        },
        "type": {
          "type": "string",
          "enum": [
            "human",
            "ai"
          ],
          "description": "Whether this is a human developer or AI agent"
        },
        "active": {
          "type": "boolean",
          "description": "Whether the agent is available for task assignment",
          "default": true
        },
        "skills": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Technical skills (e.g. ['react', 'typescript', 'go'])"
        },
        "specialization": {
          "type": "string",
          "enum": [
            "frontend",
            "backend",
            "fullstack",
            "testing",
            "devops",
            "maintenance"
          ],
          "description": "Primary area of expertise"
        },
        "instructions": {
          "type": "string",
          "description": "Agent-specific guidelines and working preferences"
        },
        "velocity_points_per_hour": {
          "type": "number",
          "minimum": 0,
          "description": "Measured performance in complexity points per hour"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        },
        "agent_type": {
          "type": "string",
          "enum": [
            "coding",
            "maintenance",
            "research",
            "testing",
            "deployment",
            "analysis"
          ],
          "description": "The type of agent: coding (implements features), maintenance (janitor/cleanup), research (investigates/explores), testing (QA/validation), deployment (CI/CD/ops), analysis (code analysis/metrics)",
          "default": "coding"
        }
      }
    },
    {
      "name": "Pattern",
      "description": "A reusable implementation pattern discovered in or applied to the codebase. Patterns can be core (built-in) or project-specific.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'optimistic-update')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'Optimistic Update Pattern')"
        },
        "type": {
          "type": "string",
          "enum": [
            "ui",
            "api",
            "data",
            "state",
            "error",
            "auth",
            "navigation",
            "layout"
          ],
          "description": "Pattern category"
        },
        "scope": {
          "type": "string",
          "enum": [
            "core",
            "project"
          ],
          "description": "Whether this is a built-in core pattern or project-specific"
        },
        "description": {
          "type": "string",
          "description": "What the pattern does and when to use it"
        },
        "example_code": {
          "type": "string",
          "description": "Abstract example implementation"
        },
        "usage_guidance": {
          "type": "string",
          "description": "When to apply this pattern and considerations"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Constitution",
      "description": "Project-wide non-negotiable principles that all Changes must adhere to. Encodes architectural patterns, security guardrails, and testing requirements.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'project-constitution')"
        },
        "version": {
          "type": "string",
          "description": "Semantic version (e.g. '1.0.0')"
        },
        "principles": {
          "type": "string",
          "description": "High-level architectural principles"
        },
        "guardrails": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Non-negotiable rules (e.g. 'no-orm', 'all-endpoints-authenticated')"
        },
        "testing_requirements": {
          "type": "string",
          "description": "Required testing standards"
        },
        "security_requirements": {
          "type": "string",
          "description": "Security guardrails and requirements"
        },
        "patterns_required": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Pattern names that MUST be used for certain contexts"
        },
        "patterns_forbidden": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Pattern names that MUST NOT be used"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Change",
      "description": "Container for a feature, bug fix, or refactoring effort. Contains four artifacts: Proposal (why), Specs (what), Design (how), Tasks (steps).",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'add-user-permissions')"
        },
        "status": {
          "type": "string",
          "enum": [
            "active",
            "archived"
          ],
          "description": "Change lifecycle status"
        },
        "base_commit": {
          "type": "string",
          "description": "Git commit SHA when the change started"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Proposal",
      "description": "The intent of a change: why we're doing this and what's in scope. Does NOT contain requirements (those go in Specs).",
      "properties": {
        "intent": {
          "type": "string",
          "description": "Problem statement and motivation (the 'why')"
        },
        "scope": {
          "type": "string",
          "description": "What's in scope and out of scope"
        },
        "impact": {
          "type": "string",
          "description": "Affected areas, risks, and considerations"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Spec",
      "description": "A domain-specific specification container (e.g. auth, payments, ui). Contains requirements and their scenarios.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'auth', 'payments', 'ui-theme')"
        },
        "domain": {
          "type": "string",
          "description": "Domain area this spec covers"
        },
        "purpose": {
          "type": "string",
          "description": "High-level description of this spec's domain"
        },
        "delta_type": {
          "type": "string",
          "enum": [
            "added",
            "modified",
            "removed"
          ],
          "description": "Type of change for change tracking"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Requirement",
      "description": "A specific behavior the system must have. Lives under a Spec. Uses RFC 2119 keywords (MUST, SHALL, SHOULD, MAY).",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-authentication', 'session-expiration')"
        },
        "description": {
          "type": "string",
          "description": "The requirement statement (e.g. 'The system SHALL issue a JWT token upon successful login')"
        },
        "strength": {
          "type": "string",
          "enum": [
            "MUST",
            "SHALL",
            "SHOULD",
            "MAY"
          ],
          "description": "RFC 2119 requirement strength"
        },
        "delta_type": {
          "type": "string",
          "enum": [
            "added",
            "modified",
            "removed"
          ],
          "description": "Type of change for change tracking"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Scenario",
      "description": "A concrete example of a requirement in action. Testable \u2014 you could write an automated test for each scenario.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'valid-credentials', 'invalid-credentials')"
        },
        "title": {
          "type": "string",
          "description": "Human-readable title (e.g. 'Valid Credentials Login')"
        },
        "given": {
          "type": "string",
          "description": "Precondition (e.g. 'a user with valid credentials')"
        },
        "when": {
          "type": "string",
          "description": "Action (e.g. 'the user submits login form')"
        },
        "then": {
          "type": "string",
          "description": "Expected outcome (e.g. 'a JWT token is returned')"
        },
        "and_also": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Additional expected outcomes"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "ScenarioStep",
      "description": "A step in a complex scenario that needs step-by-step breakdown. Optional \u2014 simple scenarios may not need steps.",
      "properties": {
        "sequence": {
          "type": "integer",
          "minimum": 1,
          "description": "Step order (1, 2, 3, ...)"
        },
        "description": {
          "type": "string",
          "description": "What happens in this step"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Design",
      "description": "Technical approach and architecture decisions for a change.",
      "properties": {
        "approach": {
          "type": "string",
          "description": "Technical approach and high-level design"
        },
        "decisions": {
          "type": "string",
          "description": "Key architecture decisions and rationale"
        },
        "data_flow": {
          "type": "string",
          "description": "How data moves through the system"
        },
        "file_changes": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Expected files to create or modify"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Task",
      "description": "An implementation task with tracking, dependency management, and artifact production.",
      "properties": {
        "number": {
          "type": "string",
          "description": "Task identifier (e.g. 'T1', 'T2', 'T3')"
        },
        "description": {
          "type": "string",
          "description": "What to implement"
        },
        "task_type": {
          "type": "string",
          "enum": [
            "implementation",
            "testing",
            "documentation",
            "refactoring",
            "investigation",
            "maintenance"
          ],
          "description": "What kind of work this task represents"
        },
        "status": {
          "type": "string",
          "enum": [
            "pending",
            "in_progress",
            "completed",
            "blocked"
          ],
          "description": "Current task status"
        },
        "complexity_points": {
          "type": "integer",
          "minimum": 1,
          "maximum": 10,
          "description": "Complexity estimate (1-10 points, NOT hours)"
        },
        "started_at": {
          "type": "string",
          "format": "date-time",
          "description": "When work began"
        },
        "completed_at": {
          "type": "string",
          "format": "date-time",
          "description": "When work finished"
        },
        "actual_hours": {
          "type": "number",
          "minimum": 0,
          "description": "Actual hours spent (calculated from started_at/completed_at)"
        },
        "artifacts": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Paths to deliverables produced"
        },
        "verification_method": {
          "type": "string",
          "enum": [
            "manual",
            "automated",
            "screenshot",
            "test"
          ],
          "description": "How task completion was verified"
        },
        "verification_notes": {
          "type": "string",
          "description": "Notes on how completion was verified"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "TestCase",
      "description": "Links scenarios to executable test files for validation. Enables CI integration and verification.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'test-valid-login')"
        },
        "test_file": {
          "type": "string",
          "description": "Path to the test file (e.g. 'tests/auth/login.test.ts')"
        },
        "test_function": {
          "type": "string",
          "description": "Specific test function name (optional)"
        },
        "test_framework": {
          "type": "string",
          "enum": [
            "jest",
            "pytest",
            "go-test",
            "vitest",
            "playwright"
          ],
          "description": "Test framework used"
        },
        "status": {
          "type": "string",
          "enum": [
            "untested",
            "passing",
            "failing",
            "skipped"
          ],
          "description": "Current test status"
        },
        "last_run_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the test was last executed"
        },
        "coverage_percent": {
          "type": "number",
          "minimum": 0,
          "maximum": 100,
          "description": "Code coverage percentage"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "APIContract",
      "description": "Machine-readable API definition that complements human-readable Specs. Addresses the AI-API gap.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-api-contract')"
        },
        "format": {
          "type": "string",
          "enum": [
            "openapi",
            "asyncapi",
            "typespec",
            "smithy",
            "graphql",
            "grpc"
          ],
          "description": "Contract format"
        },
        "version": {
          "type": "string",
          "description": "Spec version (e.g. '3.1.0')"
        },
        "file_path": {
          "type": "string",
          "description": "Path to the contract file (e.g. 'api/openapi.yaml')"
        },
        "base_url": {
          "type": "string",
          "format": "uri",
          "description": "API base URL"
        },
        "description": {
          "type": "string",
          "description": "What this contract covers"
        },
        "auto_generated": {
          "type": "boolean",
          "description": "Whether the contract was generated from code"
        },
        "last_validated_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the contract was last validated against implementation"
        },
        "validation_status": {
          "type": "string",
          "enum": [
            "valid",
            "invalid",
            "unknown"
          ],
          "description": "Current validation status"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Context",
      "description": "A screen, modal, panel, or interaction surface in the application. Extracted from codebase during sync.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-management-screen')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'User Management Screen')"
        },
        "type": {
          "type": "string",
          "enum": [
            "screen",
            "modal",
            "panel",
            "notification",
            "external"
          ],
          "description": "Kind of interaction surface"
        },
        "scope": {
          "type": "string",
          "enum": [
            "internal",
            "external"
          ],
          "description": "Whether internal or external facing"
        },
        "platform": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Target platforms (e.g. ['web', 'mobile'])"
        },
        "description": {
          "type": "string",
          "description": "Purpose and behavior"
        },
        "file_path": {
          "type": "string",
          "description": "Path to implementation file"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "UIComponent",
      "description": "A reusable UI component. Extracted from codebase during sync.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'user-list')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'User List Component')"
        },
        "type": {
          "type": "string",
          "enum": [
            "primitive",
            "composite",
            "layout",
            "container"
          ],
          "description": "Component category"
        },
        "file_path": {
          "type": "string",
          "description": "Path to implementation file"
        },
        "description": {
          "type": "string",
          "description": "Purpose and usage"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Action",
      "description": "A user action or system operation (navigation, mutation, trigger, etc.).",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'update-user-role')"
        },
        "display_label": {
          "type": "string",
          "description": "Human-readable label (e.g. 'Update Role')"
        },
        "type": {
          "type": "string",
          "enum": [
            "navigation",
            "mutation",
            "trigger",
            "toggle",
            "external"
          ],
          "description": "Action category"
        },
        "description": {
          "type": "string",
          "description": "What the action does"
        },
        "handler_path": {
          "type": "string",
          "description": "Path to handler implementation"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "App",
      "description": "A deployable application in the monorepo. Can be frontend, backend, desktop, mobile, CLI tool, or library.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'web-frontend', 'auth-service', 'admin-desktop')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'Web Frontend Application')"
        },
        "app_type": {
          "type": "string",
          "enum": [
            "frontend",
            "backend",
            "desktop",
            "mobile",
            "cli",
            "library"
          ],
          "description": "Type of application"
        },
        "platform": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Target platforms (e.g. ['web'], ['ios', 'android'], ['macos', 'windows', 'linux'])"
        },
        "root_path": {
          "type": "string",
          "description": "Root directory in monorepo (e.g. 'apps/web', 'services/auth', 'desktop/admin')"
        },
        "description": {
          "type": "string",
          "description": "Purpose and scope of this application"
        },
        "tech_stack": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Main technologies (e.g. ['react', 'typescript', 'vite'], ['go', 'grpc'])"
        },
        "instructions": {
          "type": "string",
          "description": "App-specific instructions for setup, build, run, test, and deployment"
        },
        "deployment_target": {
          "type": "string",
          "description": "Where this app deploys (e.g. 'vercel', 'kubernetes', 'app-store', 'npm')"
        },
        "entry_point": {
          "type": "string",
          "description": "Main entry file (e.g. 'src/main.tsx', 'cmd/server/main.go')"
        },
        "port": {
          "type": "integer",
          "description": "Default port for local development (if applicable)"
        },
        "dependencies": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Key external dependencies (package names)"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags (e.g. 'layer:frontend', 'status:production', 'team:platform')"
        }
      }
    },
    {
      "name": "DataModel",
      "description": "A domain data type shared across the system. Can be defined in one app and consumed by others.",
      "properties": {
        "name": {
          "type": "string",
          "description": "Unique identifier (e.g. 'User', 'Organization', 'Payment')"
        },
        "display_name": {
          "type": "string",
          "description": "Human-readable name (e.g. 'User Profile')"
        },
        "description": {
          "type": "string",
          "description": "Purpose and structure of this model"
        },
        "platform": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Platforms where this model is defined (e.g. ['go', 'typescript', 'swift'])"
        },
        "file_path": {
          "type": "string",
          "description": "Primary definition file (e.g. 'models/user.go', 'types/User.ts')"
        },
        "go_type": {
          "type": "string",
          "description": "Go struct name if different from name"
        },
        "swift_type": {
          "type": "string",
          "description": "Swift struct name if different from name"
        },
        "ts_type": {
          "type": "string",
          "description": "TypeScript interface/type name if different from name"
        },
        "fields": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Key field names"
        },
        "persistence": {
          "type": "string",
          "enum": [
            "database",
            "memory",
            "cache",
            "none"
          ],
          "description": "Where this model is persisted"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "GraphSync",
      "description": "Tracks synchronization state between the Emergent graph and the codebase.",
      "properties": {
        "last_synced_commit": {
          "type": "string",
          "description": "Git commit hash of last sync"
        },
        "last_synced_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the last sync occurred"
        },
        "status": {
          "type": "string",
          "enum": [
            "synced",
            "stale",
            "syncing",
            "error"
          ],
          "description": "Current sync status"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags"
        }
      }
    },
    {
      "name": "Improvement",
      "description": "Lightweight improvement idea that doesn't require full Change workflow. Can have tasks as checklist items. Used for small enhancements, refactoring, tech debt, and quick wins.",
      "properties": {
        "title": {
          "type": "string",
          "description": "Short summary (e.g. 'Add loading spinner to user list')"
        },
        "description": {
          "type": "string",
          "description": "Detailed explanation of the improvement and its value"
        },
        "domain": {
          "type": "string",
          "enum": [
            "ui",
            "ux",
            "performance",
            "security",
            "api",
            "data",
            "testing",
            "infrastructure",
            "documentation",
            "accessibility"
          ],
          "description": "What area this improvement affects"
        },
        "type": {
          "type": "string",
          "enum": [
            "enhancement",
            "refactor",
            "optimization",
            "bug_fix",
            "tech_debt",
            "cleanup",
            "dx",
            "constitution_rule",
            "pattern_proposal",
            "technology_choice",
            "best_practice"
          ],
          "description": "What kind of work this represents. Code types: enhancement, refactor, optimization, bug_fix, tech_debt, cleanup, dx. Knowledge types: constitution_rule (propose project rule), pattern_proposal (define observed pattern), technology_choice (document tech decision), best_practice (coding standard)"
        },
        "effort": {
          "type": "string",
          "enum": [
            "trivial",
            "small",
            "medium",
            "large"
          ],
          "description": "Size estimate: trivial (<1hr), small (1-4hr), medium (1-2d), large (>2d, consider Change)"
        },
        "priority": {
          "type": "string",
          "enum": [
            "low",
            "medium",
            "high",
            "critical"
          ],
          "description": "How urgent this improvement is"
        },
        "status": {
          "type": "string",
          "enum": [
            "proposed",
            "planned",
            "in_progress",
            "completed",
            "deferred",
            "rejected"
          ],
          "description": "Lifecycle: proposed \u2192 planned (tasks added) \u2192 in_progress \u2192 completed"
        },
        "proposed_at": {
          "type": "string",
          "format": "date-time",
          "description": "When this improvement was created"
        },
        "planned_at": {
          "type": "string",
          "format": "date-time",
          "description": "When status changed to 'planned' (all tasks defined)"
        },
        "completed_at": {
          "type": "string",
          "format": "date-time",
          "description": "When all tasks were completed"
        },
        "proposed_by": {
          "type": "string",
          "description": "Agent name who proposed this"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags (e.g. 'quick-win', 'api:auth', 'needs-approval')"
        },
        "trigger_quote": {
          "type": "string",
          "description": "Exact user quote that triggered this improvement (required for knowledge types)"
        },
        "evidence": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Files, commits, or observations supporting this improvement"
        },
        "proposed_amendment": {
          "type": "object",
          "description": "For constitution_rule: proposed changes to Constitution (guardrails, principles, etc.)"
        },
        "proposed_pattern": {
          "type": "object",
          "description": "For pattern_proposal: pattern definition ready to formalize (name, type, example_code, usage_guidance)"
        },
        "proposed_tech_choice": {
          "type": "object",
          "description": "For technology_choice: technology decision documentation (technology, purpose, scope, rationale)"
        },
        "proposed_best_practice": {
          "type": "object",
          "description": "For best_practice: coding standard or guideline (rule, example, benefit)"
        }
      }
    },
    {
      "name": "MaintenanceIssue",
      "description": "A data integrity or compliance problem detected by the janitor agent. Unlike feature Changes, these are reactive maintenance items that restore graph health.",
      "properties": {
        "title": {
          "type": "string",
          "description": "Short summary of the issue (e.g. 'Orphaned Spec Entities Detected')"
        },
        "description": {
          "type": "string",
          "description": "Detailed explanation of the problem and its scope"
        },
        "severity": {
          "type": "string",
          "enum": [
            "critical",
            "warning",
            "info"
          ],
          "description": "Issue severity: critical (blocks workflow), warning (should fix), info (nice to have)"
        },
        "category": {
          "type": "string",
          "enum": [
            "data_integrity",
            "compliance",
            "structural",
            "stale_entities"
          ],
          "description": "Issue category for grouping and filtering"
        },
        "status": {
          "type": "string",
          "enum": [
            "proposed",
            "approved",
            "in_progress",
            "resolved",
            "dismissed"
          ],
          "description": "Issue lifecycle: proposed \u2192 approved (user says 'go for it') \u2192 in_progress \u2192 resolved/dismissed"
        },
        "detected_at": {
          "type": "string",
          "format": "date-time",
          "description": "When the janitor detected this issue"
        },
        "detected_by": {
          "type": "string",
          "description": "Who/what detected the issue (typically 'janitor-agent')"
        },
        "janitor_run_id": {
          "type": "string",
          "description": "ID linking back to the janitor execution that found this"
        },
        "affected_count": {
          "type": "integer",
          "minimum": 1,
          "description": "Number of entities affected by this issue"
        },
        "tags": {
          "type": "array",
          "items": {
            "type": "string"
          },
          "description": "Namespaced tags (e.g. 'auto-detected', 'orphaned', 'quick-fix')"
        }
      }
    }
  ],
  "relationship_type_schemas": [
    {
      "name": "inherits_from",
      "description": "Actor inherits permissions and capabilities from another actor",
      "sourceTypes": [
        "Actor"
      ],
      "targetTypes": [
        "Actor"
      ]
    },
    {
      "name": "uses_pattern",
      "description": "Entity uses a reusable implementation pattern",
      "sourceTypes": [
        "App",
        "Context",
        "UIComponent",
        "Action",
        "ScenarioStep"
      ],
      "targetTypes": [
        "Pattern"
      ]
    },
    {
      "name": "extends_pattern",
      "description": "Project-specific pattern extends a core pattern",
      "sourceTypes": [
        "Pattern"
      ],
      "targetTypes": [
        "Pattern"
      ]
    },
    {
      "name": "has_proposal",
      "description": "Change has a proposal describing intent, scope, and impact",
      "sourceTypes": [
        "Change"
      ],
      "targetTypes": [
        "Proposal"
      ]
    },
    {
      "name": "has_spec",
      "description": "Change has a domain-specific specification",
      "sourceTypes": [
        "Change"
      ],
      "targetTypes": [
        "Spec"
      ]
    },
    {
      "name": "has_design",
      "description": "Change has a technical design",
      "sourceTypes": [
        "Change"
      ],
      "targetTypes": [
        "Design"
      ]
    },
    {
      "name": "has_task",
      "description": "Parent entity has an implementation task",
      "sourceTypes": [
        "Change",
        "Improvement"
      ],
      "targetTypes": [
        "Task"
      ]
    },
    {
      "name": "has_requirement",
      "description": "Spec contains a requirement",
      "sourceTypes": [
        "Spec"
      ],
      "targetTypes": [
        "Requirement"
      ]
    },
    {
      "name": "has_scenario",
      "description": "Requirement has a concrete scenario example",
      "sourceTypes": [
        "Requirement"
      ],
      "targetTypes": [
        "Scenario"
      ]
    },
    {
      "name": "executed_by",
      "description": "Scenario is executed by an actor",
      "sourceTypes": [
        "Scenario"
      ],
      "targetTypes": [
        "Actor"
      ]
    },
    {
      "name": "has_step",
      "description": "Scenario has an ordered step",
      "sourceTypes": [
        "Scenario"
      ],
      "targetTypes": [
        "ScenarioStep"
      ]
    },
    {
      "name": "variant_of",
      "description": "Scenario is an alternative path of another scenario",
      "sourceTypes": [
        "Scenario"
      ],
      "targetTypes": [
        "Scenario"
      ]
    },
    {
      "name": "occurs_in",
      "description": "Scenario step occurs in a context (screen, modal, etc.)",
      "sourceTypes": [
        "ScenarioStep"
      ],
      "targetTypes": [
        "Context"
      ]
    },
    {
      "name": "performs",
      "description": "Scenario step performs an action",
      "sourceTypes": [
        "ScenarioStep"
      ],
      "targetTypes": [
        "Action"
      ]
    },
    {
      "name": "composed_of",
      "description": "UI component is composed of child components",
      "sourceTypes": [
        "UIComponent"
      ],
      "targetTypes": [
        "UIComponent"
      ]
    },
    {
      "name": "uses_component",
      "description": "Context uses a UI component",
      "sourceTypes": [
        "Context"
      ],
      "targetTypes": [
        "UIComponent"
      ]
    },
    {
      "name": "nested_in",
      "description": "Context is nested inside another context (e.g. modal inside screen)",
      "sourceTypes": [
        "Context"
      ],
      "targetTypes": [
        "Context"
      ]
    },
    {
      "name": "available_in",
      "description": "Action is available in a context",
      "sourceTypes": [
        "Action"
      ],
      "targetTypes": [
        "Context"
      ]
    },
    {
      "name": "navigates_to",
      "description": "Action navigates to a target context",
      "sourceTypes": [
        "Action"
      ],
      "targetTypes": [
        "Context"
      ]
    },
    {
      "name": "has_subtask",
      "description": "Task has a subtask",
      "sourceTypes": [
        "Task"
      ],
      "targetTypes": [
        "Task"
      ]
    },
    {
      "name": "blocks",
      "description": "Task blocks another task (dependency). Emergent auto-creates inverse 'blocked_by'.",
      "sourceTypes": [
        "Task"
      ],
      "targetTypes": [
        "Task"
      ]
    },
    {
      "name": "blocked_by",
      "description": "Task is blocked by another task (auto-created inverse of 'blocks')",
      "sourceTypes": [
        "Task"
      ],
      "targetTypes": [
        "Task"
      ]
    },
    {
      "name": "implements",
      "description": "Task implements an entity (spec, context, component, action, or pattern)",
      "sourceTypes": [
        "Task"
      ],
      "targetTypes": [
        "Spec",
        "Context",
        "UIComponent",
        "Action",
        "Pattern"
      ]
    },
    {
      "name": "assigned_to",
      "description": "Task is assigned to a coding agent",
      "sourceTypes": [
        "Task"
      ],
      "targetTypes": [
        "Agent"
      ]
    },
    {
      "name": "governed_by",
      "description": "Change must adhere to a constitution",
      "sourceTypes": [
        "Change"
      ],
      "targetTypes": [
        "Constitution"
      ]
    },
    {
      "name": "requires_pattern",
      "description": "Constitution mandates the use of a pattern",
      "sourceTypes": [
        "Constitution"
      ],
      "targetTypes": [
        "Pattern"
      ]
    },
    {
      "name": "forbids_pattern",
      "description": "Constitution forbids the use of a pattern",
      "sourceTypes": [
        "Constitution"
      ],
      "targetTypes": [
        "Pattern"
      ]
    },
    {
      "name": "tested_by",
      "description": "Scenario is validated by a test case",
      "sourceTypes": [
        "Scenario"
      ],
      "targetTypes": [
        "TestCase"
      ]
    },
    {
      "name": "tests",
      "description": "Test case validates a scenario",
      "sourceTypes": [
        "TestCase"
      ],
      "targetTypes": [
        "Scenario"
      ]
    },
    {
      "name": "has_contract",
      "description": "Spec has a machine-readable API contract",
      "sourceTypes": [
        "Spec"
      ],
      "targetTypes": [
        "APIContract"
      ]
    },
    {
      "name": "implements_contract",
      "description": "Entity implements an API contract endpoint",
      "sourceTypes": [
        "Context",
        "Action"
      ],
      "targetTypes": [
        "APIContract"
      ]
    },
    {
      "name": "owned_by",
      "description": "Entity is owned/maintained by a coding agent",
      "sourceTypes": [
        "Spec",
        "Context",
        "UIComponent",
        "Action"
      ],
      "targetTypes": [
        "Agent"
      ]
    },
    {
      "name": "belongs_to_app",
      "description": "Entity belongs to an app (implementation artifact owned by app)",
      "sourceTypes": [
        "Context",
        "UIComponent",
        "Action",
        "APIContract"
      ],
      "targetTypes": [
        "App"
      ]
    },
    {
      "name": "scoped_to_app",
      "description": "Workflow artifact or improvement affects or is scoped to specific app(s)",
      "sourceTypes": [
        "Change",
        "Spec",
        "Requirement",
        "Design",
        "Task",
        "Improvement"
      ],
      "targetTypes": [
        "App"
      ]
    },
    {
      "name": "depends_on_app",
      "description": "App depends on another app at runtime (e.g. frontend calls backend API)",
      "sourceTypes": [
        "App"
      ],
      "targetTypes": [
        "App"
      ]
    },
    {
      "name": "provides_model",
      "description": "App owns and defines a DataModel (source of truth)",
      "sourceTypes": [
        "App"
      ],
      "targetTypes": [
        "DataModel"
      ]
    },
    {
      "name": "consumes_model",
      "description": "App uses a DataModel from another app (consumer)",
      "sourceTypes": [
        "App"
      ],
      "targetTypes": [
        "DataModel"
      ]
    },
    {
      "name": "exposes_api",
      "description": "App exposes an API contract for external consumption",
      "sourceTypes": [
        "App"
      ],
      "targetTypes": [
        "APIContract"
      ]
    },
    {
      "name": "affects_entity",
      "description": "Issue or improvement affects a specific entity",
      "sourceTypes": [
        "MaintenanceIssue",
        "Improvement"
      ],
      "targetTypes": [
        "Change",
        "Proposal",
        "Spec",
        "Requirement",
        "Scenario",
        "Design",
        "Task",
        "Context",
        "UIComponent",
        "Action",
        "Pattern"
      ]
    },
    {
      "name": "parent_issue",
      "description": "MaintenanceIssue is part of a larger parent issue (for grouping related problems)",
      "sourceTypes": [
        "MaintenanceIssue"
      ],
      "targetTypes": [
        "MaintenanceIssue"
      ]
    },
    {
      "name": "resolved_by_change",
      "description": "MaintenanceIssue was resolved by implementing a Change (if code changes were needed)",
      "sourceTypes": [
        "MaintenanceIssue"
      ],
      "targetTypes": [
        "Change"
      ]
    },
    {
      "name": "proposed_by",
      "description": "Entity was proposed/detected by a coding agent",
      "sourceTypes": [
        "MaintenanceIssue",
        "Improvement"
      ],
      "targetTypes": [
        "Agent"
      ]
    },
    {
      "name": "promoted_to_change",
      "description": "Improvement was promoted to a formal Change",
      "sourceTypes": [
        "Improvement"
      ],
      "targetTypes": [
        "Change"
      ]
    },
    {
      "name": "superseded_by",
      "description": "Improvement was superseded by a better/newer improvement",
      "sourceTypes": [
        "Improvement"
      ],
      "targetTypes": [
        "Improvement"
      ]
    }
  ],
  "ui_configs": {},
  "extraction_prompts": {}
}